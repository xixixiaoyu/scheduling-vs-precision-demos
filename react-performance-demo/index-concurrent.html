<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React 并发模式性能优化演示</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu',
          'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background-color: #f5f5f5;
        margin: 0;
        padding: 20px;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 30px;
      }

      .input-container {
        margin-bottom: 20px;
      }

      input {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
      }

      input:focus {
        outline: none;
        border-color: #4a90e2;
        box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
      }

      .list-container {
        height: 400px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      li {
        padding: 10px 15px;
        border-bottom: 1px solid #eee;
      }

      li:last-child {
        border-bottom: none;
      }

      li:hover {
        background-color: #f9f9f9;
      }

      .performance-info {
        margin-top: 20px;
        padding: 15px;
        background-color: #e8f5e9;
        border-radius: 4px;
        border-left: 4px solid #4caf50;
      }

      .performance-info h3 {
        margin-top: 0;
        color: #2e7d32;
      }

      .performance-info p {
        margin-bottom: 0;
        color: #666;
      }

      .comparison {
        margin-top: 20px;
        padding: 15px;
        background-color: #e3f2fd;
        border-radius: 4px;
        border-left: 4px solid #2196f3;
      }

      .comparison h3 {
        margin-top: 0;
        color: #1565c0;
      }

      .comparison p {
        margin-bottom: 0;
        color: #666;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, startTransition } = React

      // 生成大量数据的函数
      const generateLargeDataSet = (count) => {
        const data = []
        for (let i = 0; i < count; i++) {
          data.push({
            id: i,
            text: `项目 ${i}: ${
              ['苹果', '香蕉', '橙子', '葡萄', '草莓', '西瓜', '芒果', '柠檬'][
                Math.floor(Math.random() * 8)
              ]
            } - ${Math.random().toString(36).substring(2, 10)}`,
          })
        }
        return data
      }

      function FilterableList() {
        // 生成 100,000 个对象的数组
        const [allItems] = useState(() => generateLargeDataSet(100000))
        const [filterText, setFilterText] = useState('')
        const [filteredItems, setFilteredItems] = useState(allItems)
        const [isProcessing, setIsProcessing] = useState(false)

        // 当输入变化时，过滤数据（使用并发特性）
        const handleInputChange = (e) => {
          const value = e.target.value

          // 立即更新输入框的值，保持 UI 响应
          setFilterText(value)

          // 标记开始处理
          setIsProcessing(true)

          // 关键优化：使用 startTransition 将状态更新标记为非紧急，避免阻塞UI
          // 这允许 React 在处理大量数据时优先处理用户输入，保持界面流畅
          startTransition(() => {
            const startTime = performance.now()

            // 过滤大量数据，现在这个操作不会阻塞输入
            const filtered = allItems.filter((item) =>
              item.text.toLowerCase().includes(value.toLowerCase())
            )

            const endTime = performance.now()
            console.log(`过滤耗时: ${endTime - startTime} 毫秒`)

            setFilteredItems(filtered)
            setIsProcessing(false)
          })
        }

        return (
          <div className="container">
            <h1>React 并发模式性能优化演示</h1>

            <div className="input-container">
              <input
                type="text"
                value={filterText}
                onChange={handleInputChange}
                placeholder="尝试输入文字过滤列表... 注意输入现在保持流畅"
                style={{
                  borderColor: isProcessing ? '#4caf50' : '#ddd',
                  backgroundColor: isProcessing ? '#f1f8e9' : 'white',
                }}
              />
              {isProcessing && (
                <div style={{ color: '#4caf50', marginTop: '5px' }}>后台处理中...</div>
              )}
            </div>

            <div className="list-container">
              <ul>
                {filteredItems.map((item) => (
                  <li key={item.id}>{item.text}</li>
                ))}
              </ul>
            </div>

            <div className="performance-info">
              <h3>并发优化说明</h3>
              <p>
                这个演示展示了使用 React 18 的 <code>startTransition</code> API 如何解决性能问题。
                当您在输入框中输入文字时，输入框的更新是立即的，而耗时的列表过滤操作被标记为"过渡"，
                React 会在不阻塞用户输入的情况下处理这些更新。
              </p>
              <p>
                <strong>尝试：</strong>快速输入文字，注意输入框现在保持响应，没有明显的延迟。
              </p>
            </div>

            <div className="comparison">
              <h3>与阻塞模式对比</h3>
              <p>
                在之前的阻塞模式中，每次输入都会立即触发100,000项数据的列表过滤，导致严重的UI阻塞。
                而在这个并发模式中，输入框的更新优先级高，列表更新的优先级低，用户体验显著提升。
                这是 React 18 并发特性的核心优势：让应用保持响应，即使在处理大量数据时。
              </p>
            </div>
          </div>
        )
      }

      // 渲染应用
      const root = ReactDOM.createRoot(document.getElementById('root'))
      root.render(<FilterableList />)
    </script>
  </body>
</html>
